# Схема функционального события
ссылка на схемы https://miro.com/app/board/uXjVImM_ywk=/?share_link_id=689404333085

Событие TaskSolved продусится сервисом найма, обрабатывается сервисом бонусов

Пример события:
```json
{  
  "event_id": "90a91f4b-8e34-4a3c-bfc8-f6649597445e",  
  "event_name": "TaskSolved.v0",  
  "produced_at": "2025-02-13T17:11:30Z",  
  "payload": {  
    "task_uid": "uidf9g94ghiure",  
    "task_manager_uid": "fihij8v4rei"  
  }  
}
```
Схема события:
```json
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "type": "object",
    "title": "TaskSolved.v0",
    "description": "JSON schema for 'task solved' functional event",
    "properties": {
        "event_id": {
            "type": "string",
            "description": "Уникальный идентификатор события"
        },
        "event_name": {
            "type": "string",
            "enum": ["TaskSolved"],
            "description": "Название события"
        },
        "event_version": {
            "type": "string",
            "enum": ["0"],
            "description": "Версия события"
        },
        "produced_at": {
            "type": "string",
            "format": "date-time",
            "description": "Время создания события"
        },
        "payload": {
            "type": "object",
            "properties": {
                "task_uid": {
                    "type": "string",
                    "description": "Уникальный идентификатор задачи. uuid4"
                },
                "task_manager_uid": {
                    "type": "string",
                    "description": "Уникальный идентификатор менеджера задачи. uuid4"
                }
            },
            "required": ["task_uid", "task_manager_uid"],
            "additionalProperties": false
        }
    },
    "required": ["event_id", "event_name", "event_version", "produced_at", "payload"],
    "additionalProperties": false
}
```

В моей схеме сервис бонусов не хранит инфу и о таске, кроме отображения task_uid: task_rating. Сервис бонусов принимая событие может по task_manager_uid полчить инфо о менеджере и по task_uid рейтинг задачи.
task_manager_uid - менеджер задачи на момент ее решения. Если например для задачи переназначат другого менеджера для переделки до того как событие дойдет, то в такой реализации деньги начислятся правильному менеджеру

# Схема формального события
Событие NewCandidate продусится сервисом найма, обрабатывается сервисом создания и поддержки заданий

Пример события:
```json
{  
  "event_id": "90a91f4b-8e34-4a3c-bfc8-f6649597445e",  
  "event_name": "NewCandidate.v0",  
  "produced_at": "2025-02-13T17:11:30Z",  
  "payload": {  
	  "candidate_uid": "uidf9g94ghiure",  
	  "name": "Marlon",  
	  "surname": "Brando"  
	}
}
```
Схема события:
```json
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "type": "object",
    "title": "NewCandidate.v0",
    "description": "JSON schema for 'new candidate' formal event",
    "properties": {
        "event_id": {
            "type": "string",
            "pattern": "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$",
            "description": "Уникальный идентификатор события"
        },
        "event_name": {
            "type": "string",
            "enum": ["NewCandidate"],
            "description": "Название события"
        },
        "event_version": {
            "type": "string",
            "enum": ["0"],
            "description": "Версия события"
        },
        "produced_at": {
            "type": "string",
            "format": "date-time",
            "description": "Время создания события"
        },
        "payload": {
            "type": "object",
            "properties": {
                "candidate_uid": {
                    "type": "string",
                    "description": "Уникальный идентификатор кандидата. uuid4"
                },
                "name": {
                    "type": "string",
                    "description": "Имя кандидата"
                },
                "surname": {
                    "type": "string",
                    "description": "Фамилия кандидата"
                }
            },
            "required": ["candidate_uid", "name", "surname"],
            "additionalProperties": false
        }
    },
    "required": ["event_id", "event_name", "event_version" "produced_at", "payload"],
    "additionalProperties": false
}

```
Это событие о новом кандидате -  у него по умолчанию не может быть ни задачи ни менеджера ни ответа на задачу, поэтому тут событие без этих полей. Можно условно считать это дельта событием - по умолчанию у новых кандидатов перечисленные выше поля пустые.

# Миграция связей

## Формальная связь sync -> async

Streaming: manager: sync -> async

Передача менеджера из сервиса создания и поддержки заданий в сервис бонусов

0) сейчас сервис бонусов по необходимости шлет НТТР запрос о менеджере в сервис создания и поддержки заданий в метод get_manager, сохраняет ответ в базу
1) добавить схему события в СхемаРегистри
2) завести очередь и добавить обработчик в сервис бонусов. во время переходного периода перезаписывать данные, данными из запроса, потому что они консистентны.
3) добавить отправку событий о менеджере в сервис заданий
4) отключить отправку НТТР запроса из сервиса бонусов
5) удалить метод get_manager и код отправки запроса в сервисе


## Формальная связь async -> sync

Streaming: test_task_updated: async -> sync

Обновление задания из сервиса создания и поддержки заданий в сервис найма

тут буду использовать push модель. обновлять задание надо как можно скорее, сервис заданий знает когда конкретно оно обновилось и может асап запушить обновления в сервис найма

0) сейчас сервис заданий публикует событие об обновлении заданий, сервси найма принимает события
1) добавить метод update_task в сервис найма
2) добавить код вызывающий update_task и удалить создание событий в сервисе заданий
3) подождать пока все события оставшиеся в очереди обработаются (тут есть смысл отсылать в методе вместе с обновлением задачи таймстемп обновления, чтобы на стороне консумера выбирать последнюю версию, если обновление придет и через очередь и через метод.)
4) удалить очередь и код консумера
5) удалить событие из СхемаРегистри


***То что описано дальше, по ТЗ делать не надо, но для домашки допустим что теперь обновлять таску моментально не надо и можно сделать асинхронно, а назначение задания должно происходить по инициативе сервиса найма***
## Функциональная связь sync -> async

Business event: task need update: sync -> async

Событие о том что пора обновить задание. Событие создается сервисом найма и принимается сервисом заданий

0) сейчас сервис найма шлет НТТР запрос в сервис заданий в метод update_task
1) добавить схему события в СхемаРегистри
2) создать очередь и консумер в сервис заданий, но сохранять данные только из метода
3) добавить продусера событий в сервис найма 
4) проверить что эти события доходят до сервиса заданий. переключить на сохранение событий из консумера. в случае дублей (когда событие пришло синхронно до отключение метода, а потом еще раз из очереди) использовать ключи идемпотентности для запросов на обновление
5) удалить вызовы update_task метода
6) удалить неиспользуемый код

## Функциональная связь async -> sync

Business event: task assigned: async -> sync

Событие о том что задание назначено на кандидата. Публикуется сервисом заданий, потребляется сервисом найма

0) сейчас сервис заданий публикует событие о назначении задания. его потребляет сервис найма
1) создать метод assign_task в сервисе найма
2) отключить продусер в сервисе найма и вместо этого отправлять запросы в метод assign_task
3) подождать пока все события в очереди обработаются
4) удалть очередь и код косумера
5) удалить событие из СхемаРегистри


## Миграции для новых требований бизнеса

async Business event:  new task created </br>
сервис заданий -> сервис бонусов

было: `task_title: [Knowledge Area] Title`</br>
станет: `knowledge_area: knowledge area` и `title: title`

1) В сервисе заданий и в сервис бонусов добавить колонку `knowledge_area` (заполнена пустыми строками)
2) в продусер сервиса заданий добавить код который склеивает название из `knowledge area` и `title` если в `title` нет `[Knowledge Area]`. Иначе просто отдает старый `title`
3) в консумер сервиса бонусов добавить код разделяющий `title` на `knowledge area` и `title`
4) промигрировать бд сервиса заданий и сервиса бонусов разделив `title` на `knowledge area` и `title`.
5) добавить новую версию события в СхемаРегистри. В новой схеме есть доп поле: `knowledge_area`
6) написать код в косумер сервиса бонусов, который умеет обрабатывать событие второй версии
7) переключить продусер сервиса заданий на отправку новой схемы событий
8) подождать пока все старые версии событий обработаются
9) удалить код косумера обабатывающий старые версии событий, удалить код продусера создающий старые версии события
10) удалть старую схему из СхемаРегистри


В моей схеме изначально такого стриминга не было. Добавляю </br>
async Streaming: manager</br>
сервис заданий -> сервис найма

нужно убрать имя и фамилию менеджера и вместо них отправлять только логин </br>
предполагаю что логин менеджера уже есть в сервисе заданий

1) добавить пустую колонку `login` в бд сервиса найма, имя и фамилию сделать опциональными
2) добавить код в сервис найма который в качестве имени менеджера использует `login` вместо имени и фамилии если их нет.
3) добавить новую схему события в СхемаРегистри (убрать имя и фамилию, добавить логин)
4) написать код консумера который умеет работать с новой версией события
5) переключить продусер на создание событий новой версии
6) подождать пока все старые события обработаются
7) получить логины всех менеджеров которые хранятся у сервиса найма. Переместить их каким-либо способом из бд сервиса заданий в бд сервиса найма
8) удалить старый код продусера и косумера. В сервисе найма всегда отображать в качетстве имени только логин.
9) удалить старую схему из СхемаРегистри
10) удалить колонки имя и фамилия из бд сервиса найма

## Проблемы с зачислением/списанием средств

Для того чтобы средства не потеряли нужно 
1) иметь инфу о менеджере (айди для записи бонусов в базу и счет для зачисления). приходит в асинхронных событиях </br>
	как решить
	1) настроить **At-least-once deliver** и использовать таймстемпы в событиях чтобы понимать какие данные последние.
	2) у продусера использовать transactional outbox чтобы точно отправить событие
	3) на стороне консумера настроить dead letter exchange для случая когда по каким либо причинам сообщение не обработалось.
2) иметь рэйтинг задачи. он приходит в синхронном запросе </br>
	как решать
	1) настроить ретраи отправки рейтинга на стороне сервиса найма
3) не потерять событие о решенном/не решенном задании. приходят в событиях </br>
	как не допустить:
	1) настроить **At-least-once deliver** и использовать ключи идемпотентности чтобы не начислять бонусы дважды
	2) у продусера использовать transactional outbox чтобы точно отправить событие
	3) на стороне консумера настроить dead letter exchange для случая когда по каким либо причинам сообщение не обработалось.Например поменяли формат или не нашли у себя в базе инфу о нужном менеджере или о рейтинге задания. 
	- Для случая отсутствия менеджера или рейтинга, можно настроить отдельный DLX и ретраить обработку событий из него автоматически через какое-то время, в надежде что данные о менеджере и рейтинге таки придут в сервис.
	- Остальные DLX события обрабатывать руками.
